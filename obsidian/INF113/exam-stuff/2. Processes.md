# Von Neumann architecture 

### ALU - Arithmetic Logic Unit
- A Bus
- B Bus
- ALU control lines (use control number n)
- C Bus (output)

### Memory
- Addresses
- each address contain a byte
- probably some that support bit-level addressing

## Registers
*memory on the CPU*
- For most modern CPUs, registers are either 32-bit (4 bytes) or 64-bit (8 bytes). These bit widths align with common CPU architectures (32-bit or 64-bit).
- Some specialized registers may have different sizes. For instance, x86 CPUs have some 128-bit, 256-bit, or even 512-bit registers used for SIMD (Single Instruction, Multiple Data) operations.

## Instruction Cycle

1. **FETCH** – load the instruction that the IC points to, increment the IC
2. **DECODE** – interpret the instruction, calculate addresses needed by the instruction
3. **EXECUTE** – execute the instruction, for example:
   - $move$
   - $add$
   - $compare$
   - $jump$ (modifies the IC)
4. **WRITE BACK** – store the result in registers

### Instruction counter - IC
The **Instruction Counter (IC)** is a special register within the CPU that keeps track of the address of the next instruction to be executed. Here’s how it works in the instruction cycle:

1. **FETCH**: The IC points to the memory address of the current instruction that needs to be fetched. During this phase, the CPU retrieves the instruction from memory.
2. **INCREMENT**: After fetching, the IC is usually incremented to point to the next instruction in sequence. This increment can vary depending on the instruction length or if a jump (branch) instruction alters the control flow.
3. **JUMP/BRANCH**: If a jump, call, or branch instruction is executed, the IC is updated with a new address, making the program execution jump to a different part of the code.

Essentially, the **IC** or **Program Counter** is like a bookmark in your program, keeping track of where the CPU is in the instruction sequence. It’s critical for sequential program execution, as it ensures that instructions are processed in the correct order unless explicitly modified by control flow instructions (e.g., jumps, branches, or calls).

### OPCODES
*example of x86 opcodes*

| Opcode | Mnemonic | Operand 1 | Operand 2 | Description                |
| ------ | -------- | --------- | --------- | -------------------------- |
| 0x00   | ADD      | r/m8      | r8        | Add                        |
| 0x01   | ADD      | r/m16/32  | r16/32    | Add                        |
| 0x02   | ADD      | r8        | r/m8      | Add                        |
| 0x03   | ADD      | r16/32    | r/m16/32  | Add                        |
| 0x04   | ADD      | AL        | imm8      | Add                        |
| 0x05   | ADD      | eAX       | imm16/32  | Add                        |
| 0x06   | PUSH     | ES        |           | Push ES segment onto stack |
| 0x07   | POP      | ES        |           | Pop value into ES segment  |
| 0x08   | OR       | r/m8      | r8        | Logical Inclusive OR       |
| 0x09   | OR       | r/m16/32  | r16/32    | Logical Inclusive OR       |
| 0x0A   | OR       | r8        | r/m8      | Logical Inclusive OR       |
| 0x0B   | OR       | r16/32    | r/m16/32  | Logical Inclusive OR       |
| 0x0C   | OR       | AL        | imm8      | Logical Inclusive OR       |
| 0x0D   | OR       | eAX       | imm16/32  | Logical Inclusive OR       |
| 0x0E   | PUSH     | CS        |           | Push CS segment onto stack |


## Compilation and Execution Process

1. **C Language**  
   - Written code in C.
   - **Compiles to** Assembly Language using:
     ```bash
     gcc -S -o foo.S foo.c
     ```

2. **Assembly Language**  
   - Low-level representation of code.
   - **Assembles into** Machine Code using:
     ```bash
     as -o foo.o foo.S
     ```

3. **Machine Code**  
   - Binary code that can be executed by the CPU.
   - **Linked to other machine code** to form an executable (Program Binary) using:
     ```bash
     ld -o foo foo.o bar.o baz.o
     ```

4. **Program Binary**  
   - The final executable file that can run on the CPU.
   - **Loaded into / runs on** the CPU using:
     ```bash
     ./foo
     ```

5. **CPU Execution**  
   - The CPU loads the program binary, starting with the instruction pointer at the first address.
   - Executes the instruction cycle: **Fetch → Decode → Execute → Write Back**, etc.

##### Note:
- `gcc` and `clang` can perform all these steps in one command:
  ```bash
  gcc -o foo foo.c bar.o baz.o
```


# Syscalls

### Links to other addresses













# Program vs Process

**Program**: A sequence of instructions stored somewhere
**Process**: A running program



### Time Sharing

On the CPU, it can only run one process at a time