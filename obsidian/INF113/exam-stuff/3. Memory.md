# Virtual Memory
*Program code
Global Variables
heap
...
Stack - local variables*

**Base Pointer** (%rbp)
- Points to a fixed bottom location in the current **stack frame**.
	- A stack frame is a frame of data that gets pushed onto the stack. In the case of a call stack, a stack frame would represent a function call and its argument data
- Used to reference function parameters and local variables with stable offsets within a function's execution.
+ when building uppon the stack, this pointer will swap to the stack pointer
	+ the old basepointer will be saved, and the stack pointer will still point on the top
	+ then new stuff can be saved

**Stack Pointer** (%rsp)
- Points to the **top of the stack**, where the most recent data has been pushed.
- Changes dynamically as values are pushed or popped from the stack.

**Stack and Heap Growth**:
- The stack grows **downward** in memory as data is added (push operations).
- The heap grows **upward** in memory as more dynamic memory is allocated (e.g., with `malloc`).

#### Random but nice to know

| **Value** | **Decimal** | **Hex**    | **Little Endian** | **Big Endian** |
| --------- | ----------- | ---------- | ----------------- | -------------- |
| 1 byte    | 17          | 0x11       | 11                | 11             |
| 2 bytes   | 300         | 0x012c     | 2c 01             | 01 2c          |
| 4 bytes   | 4045364d    | 0x4045364d | 4d 36 45 40       | 40 45 36 4d    |

# Address translation 
*each process got its own visualized memory*
Program code
- The code segment where the instructions live
Heap
- The heap segment contains malloc'd data dynamic data structures (it can grow positively)
stack 
- (it grows negatively) the stack segment: contains local variables arguments to routines. return values. etc.

When multiple processes use the memory
- memory privacy
- needs to be easy to use regardless of process placement
- needs consistent placement of code, stack and heap

**32 bit systems:**
- address space is $2^{32} = 4 GB$
- A 32-bit system can address 4,294,967,296 unique memory locations (or addresses). Since each location corresponds to a single byte, this translates to a maximum of 4 GB of addressable memory.

**64 bit systems:**
- address space is $2^{64} = 16$ exabytes
- A 64-bit system can address an astronomically larger number of unique memory locations—18,446,744,073,709,551,616. This translates to a maximum of 16 exabytes of addressable memory.


# Base & Bounds
- Two more registers in the CPU hardware: base-register  & bound-register
- each process get a value of base and bound, which is moved on context-switch
- base: where memory start
- bound: where memory ends
	- can be absolute or relative 

**How it works**
- OS will find empty physical memory
- Sets base and bound for the new process
- loads code-segment from the disk

**Securing**:
- checking if address is $0<address<bound$
- out of bounds exceptions

**Calculation**
- OS calculates the physical address from virtual space address + base
- it checks if virtual address is within bounds
	- which means the virtual space is restricted
	- 
	
**Dynamic relocation**
- the ability to calculate the physical address translation while running
- the process can be moved after running if that is needed
	- OS copy address space to somewhere else


**Memory Management Unit - MMU**
- base + bound 
- each memory access needs an address translation
-  simple MMU

**Hardware needed**:
- privileged mode (already possible)
- base/bound registers (needed)
- ability to translate VA and check the bounds (needed)
- privileged instruct to update base/bound (needed)
- privileged register for exception handles 
- ability to raise exceptions, f.ex out-of-bound

**OS needed**
- memory management
	 - free list
- base bound management

**Cons**
- a lot of "internal fragmenting"


# Segmentation
*now we have 3 pairs of registers:*
- *code*
- *heap*
- *stack*

**Calculation**
- calculate offset, how far into the segment are we?
- base + offset = physical address
- offset < bounds



given a virtual address, what type is the segment
- the first two bits will specify the segment type
	- 00 is code
	- 01 is heap
	- 11 is stack
- the system knows what base address it is based on the first two bits
- the $2^2$ bits can be 4 different options
- then it will look at the offset, which is $2^{12}$ big 4096 options

- the MMU can even support protection 
- This will lead to less internal fragmentation 

| Segment | Base | Size (max 4K) | Grows Positive? | protection     |
| ------- | ---- | ------------- | --------------- | -------------- |
| Code₀₀  | 32K  | 2K            | 1               | read - execute |
| Heap₀₁  | 34K  | 3K            | 1               | read - write   |
| Stack₁₁ | 28K  | 2K            | 0               | read - write   |

*If grows negative:*
- *offset = offset - max size*
- *base + offset*

**What is needed**
- MMU has to have the segment table, and switch it in a context switch
- OS has to handle changes in wanted size of an segment
- OS has to have a free list

## Fragmenting 
*The segmenting solution ends up with segments of different sizes, something which will end up with small free bits scattered around the memory*

- This also becomes a problem when using more dynamic sizes in heap, with `malloc()` which can be shown below, where a `malloc(15)` is not possible.

| Address | 0 - 10 | 10 - 20 | 20 - 30 |
| ------- | ------ | ------- | ------- |
| Status  | Free   | Used    | Free    |

### Free List:
points from one free block to the next

- free list is implemented by a seperate linked struct
- alternative, use memory blocks to hold list pointers, each block with the next pointer of free memory
- each free block gets a header in front of it (Linux: 16 bytes)
- `*next `points to the next block in memory

```C
typedef struct __node_t {
    int size;
    struct __node_t *next;
} node_t;
```

the same way it can also be used for the memory blocks in use

```C
typedef struct header {
	int size;
	struct magic;
} header_t;
```

**magic block**
+ when we call free(), it will check the memory blocks magic number, and check if it matches your computer predefined magic number, to see if it is valid

**Splitting**

| Block Address | Length | Next Block Address |
|---------------|--------|--------------------|
| 0             | 10     | 20                 |
| 20            | 10     | NULL               |
then we do a `malloc(1)`

| Block Address | Length | Next Block Address |
|---------------|--------|--------------------|
| 0             | 10     | 20                 |
| 20            | 0      | 21                 |
| 21            | 9      | NULL               |
Simplify it:


| Block Address | Length | Next Block Address |
|---------------|--------|--------------------|
| 0             | 10     | 21                 |
| 21            | 9      | NULL               |

**Coalesce Operation**

| Block Address | Length | Next Block Address |
|---------------|--------|--------------------|
| 10            | 10     | 0                  |
| 0             | 10     | 20                 |
| 20            | 10     | NULL               |

| Block Address | Length | Next Block Address |
|---------------|--------|--------------------|
| 0             | 30     | NULL               |

**How to choose where to allocate memory?**
- Best fit:
	- Which is the closest to fit
- Worst fit:
	- Just take the most empty block
- First fit:
	- first fitting
	- small early in list
- next fit
	- we run first fit from last first fit stopped
- Buddy allocation
	- You split the allocation until it fits your `malloc(x)`
	- coalesce is easy, as if your buddy is free, you just merge

# Paging!
*Physical memory is splitted up into n many pages with an fixed size, which can hold a page each*

Virtual memory is also split into *pages*

**Page Table** 
+ The translation process is made from a table where virtual address points to a page frame 
+ the offset does not need to be affected, only the first bits representing the VPN, need to be changed to the PFN

Example:
- given 6 bit virtual address(2^6=64)
- 2 bit page number, 4 bit as offset, where each page is 16 bytes each
  
Translation:
- The offset will be the same
- vp1 -> pf7
- this will translate the first part to a physical address through the page table
- 01 -> 111 (if vp1 goes to pf7)

**Page Table structure** - 32 bit
*VPN|OFFSET*

- virtual page number $2^{20}$, where it uses 20 bits
- 3 bits is for reserved use
- 9 bits is for flags
	- valid/invalid
		- The valid/invalid bit in a page table entry (PTE) is used to indicate whether the page referenced by that entry is currently valid (i.e., mapped to physical memory) or invalid (i.e., not currently mapped to physical memory or not accessible).
	- read/write
	- user/superuser

# Pseudo example
```C
// Extract the VPN from the virtual address
unsigned int VPN = (VirtualAddress & VPN_MASK) >> SHIFT;

// Form the address of the page-table entry (PTE)
unsigned int PTEAddr = PTBR + (VPN * sizeof(PTE));

// Fetch the PTE
PTE = AccessMemory(PTEAddr);

// Check if process can access the page
if (PTE.Valid == 0) {
	RaiseException(SEGMENTATION_FAULT);
}
else if (CanAccess(PTE.ProtectBits) == 0) {
	RaiseException(PROTECTION_FAULT);
}
else {
	// Access OK: form physical address and fetch it
	unsigned int offset = VirtualAddress & OFFSET_MASK;
	unsigned int PhysAddr = (PTE.PFN << PFN_SHIFT) | offset;
	Register = AccessMemory(PhysAddr);
}
```

- PTBR is the start point of the page table
- PTBR + VPN(sizeof*(PTE) will gave the address where PTE is in the page-table
